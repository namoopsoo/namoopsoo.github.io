<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>michal.piekarczyk.xyz</title><meta name=keywords content><meta name=description content="(Porting over my notes from gists .. here ),..
quick note on imports i originally inferred this (ns blah-namespace (:use clojure.core.blah ) ; this would take all the terms in blah and put them into the current namespace (:refer-clojure :exclude [blarg flarg]) ; but this is supposed to be a way to avoid term clash ; so blarg and flarg will not be used. (not that they are in clojure.core however) ) Then I read https://www."><meta name=author content="Michal Piekarczyk"><link rel=canonical href=https://michal.piekarczyk.xyz/handy/clojure/clojure_tips/><link crossorigin=anonymous href=/assets/css/stylesheet.4c73b1b942ee612f2f6a56636bd60cf62223b2cdb42d501875d67bb952acf3c0.css integrity="sha256-THOxuULuYS8valZja9YM9iIjss20LVAYddZ7uVKs88A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://michal.piekarczyk.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://michal.piekarczyk.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://michal.piekarczyk.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://michal.piekarczyk.xyz/apple-touch-icon.png><link rel=mask-icon href=https://michal.piekarczyk.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-74MK08REDT"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-74MK08REDT",{anonymize_ip:!1})}</script><meta property="og:title" content><meta property="og:description" content="(Porting over my notes from gists .. here ),..
quick note on imports i originally inferred this (ns blah-namespace (:use clojure.core.blah ) ; this would take all the terms in blah and put them into the current namespace (:refer-clojure :exclude [blarg flarg]) ; but this is supposed to be a way to avoid term clash ; so blarg and flarg will not be used. (not that they are in clojure.core however) ) Then I read https://www."><meta property="og:type" content="article"><meta property="og:url" content="https://michal.piekarczyk.xyz/handy/clojure/clojure_tips/"><meta property="article:section" content="handy"><meta property="og:site_name" content="michal.piekarczyk.xyz"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="(Porting over my notes from gists .. here ),..
quick note on imports i originally inferred this (ns blah-namespace (:use clojure.core.blah ) ; this would take all the terms in blah and put them into the current namespace (:refer-clojure :exclude [blarg flarg]) ; but this is supposed to be a way to avoid term clash ; so blarg and flarg will not be used. (not that they are in clojure.core however) ) Then I read https://www."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Handies","item":"https://michal.piekarczyk.xyz/handy/"},{"@type":"ListItem","position":2,"name":"","item":"https://michal.piekarczyk.xyz/handy/clojure/clojure_tips/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"(Porting over my notes from gists .. here ),..\nquick note on imports i originally inferred this (ns blah-namespace (:use clojure.core.blah ) ; this would take all the terms in blah and put them into the current namespace (:refer-clojure :exclude [blarg flarg]) ; but this is supposed to be a way to avoid term clash ; so blarg and flarg will not be used. (not that they are in clojure.core however) ) Then I read https://www.","keywords":[],"articleBody":"(Porting over my notes from gists .. here ),..\nquick note on imports i originally inferred this (ns blah-namespace (:use clojure.core.blah ) ; this would take all the terms in blah and put them into the current namespace (:refer-clojure :exclude [blarg flarg]) ; but this is supposed to be a way to avoid term clash ; so blarg and flarg will not be used. (not that they are in clojure.core however) ) Then I read https://www.braveclojure.com/organization/#Anchor-3 , and read use is a shortcut for require followed by a refer. hash-maps Many ways to make a hash-map,\n; These are both fine boot.user=\u003e {:name \"Steve\" :age 24 :salary 7886 :company \"Acme\"} {:name \"Steve\", :age 24, :salary 7886, :company \"Acme\"} boot.user=\u003e {:name \"Steve\", :age 24, :salary 7886, :company \"Acme\"} {:name \"Steve\", :age 24, :salary 7886, :company \"Acme\"} how to get a value from the hash-map…\nboot.user=\u003e (steve \"age\") ; no nil boot.user=\u003e (steve 24) ; no. not even sure what this is trying to do nil boot.user=\u003e (steve :company) ; yes \"Acme\" boot.user=\u003e (steve :name) ; yes \"Steve\" what is insane is that this is also legal… and I see this one used more often:\nboot.user=\u003e (:name steve) \"Steve\" and get too..\nboot.user=\u003e (get steve :company) \"Acme\" accessing nested hashes…\napp.core=\u003e (get-in {:foo {:and \"yes\" :here \"no\"}} [:foo :here]) \"no\" Array things similarly can index arrays like hash-maps…\nboot.user=\u003e (def a1 [1 2 3 4]) #'boot.user/a1 boot.user=\u003e a1 [1 2 3 4] boot.user=\u003e (first a1) 1 Boot-repl According to https://github.com/boot-clj/boot , you can set environmental variables …\nboot.user=\u003e (set-env! #_=\u003e :resource-paths #{\"src\"} #_=\u003e :dependencies '[[me.raynes/conch \"0.8.0\"]]) but this is not working for me or at least not for the REPL i’m in,\nboot.user=\u003e (:development env) nil boot.user=\u003e (set-env! #_=\u003e :development true) nil boot.user=\u003e boot.user=\u003e (:development env) nil And to look at one or more of what is in env\nboot.user=\u003e (use '[environ.core :as env]) nil ; now you can look at anything with boot.user=\u003e (env :term) \"xterm-256color\" and clojure re-writes envrironmental variables, changing CAPITAL_LETTERS into capital-letters, so if on shell one did export CAPITAL_LETTERS=bingo Then environ.core could get this with (env :capital-letters) lambda functions in clojure ( aka anonymous functions) the #(...)\nboot.user=\u003e (#(+ %1 5) 2) 7 boot.user=\u003e (#(+ %1 5) 2 3) clojure.lang.ArityException: Wrong number of args (2) passed to: user/eval5691/fn--5692 boot.user=\u003e (#(+ %1 5 %2) 2 3) 10 actually, another nicer looking lambda form. I like this more..\nboot.user=\u003e (map (fn [x] (x :name)) [{:name \"Jo\"},{:name \"Jane\"},{:hmm \"Yea\"}]) (\"Jo\" \"Jane\" nil) boot.user=\u003e anonymous func approach to collecting keys from hash…\napp.core=\u003e ((fn [{:keys [status error]}] (println status error)) {:status 400 :error false}) 400 false nil Another note on conj and hashes… conj hashes, app.core=\u003e (def blah {\"acc\" \"123\"}) #'app.core/blah app.core=\u003e blah {\"acc\" \"123\"} app.core=\u003e (conj blah {\"secret\" \"455\"}) {\"acc\" \"123\", \"secret\" \"455\"} app.core=\u003e (conj blah {\"secret\" \"455\" \"client_id\" \"5667\"}) {\"acc\" \"123\", \"secret\" \"455\", \"client_id\" \"5667\"} a weird way of calling a func using apply, and some strange dereferencing thing , Best quote about apply i read is …\napply is used to apply an operator to its operands.\nso apply takes a func as its first arg and then throws whatever is next , 1 or more args, to func.\nI Guess that’s a lie, because the thing is though, you want to give func a list thing.\nboot.user=\u003e (max 1 2 3 4 ) 4 boot.user=\u003e (apply #(+ %1 %3) '[4 5 6 ]) 10 but all of these forms seem to work which is weird\nboot.user=\u003e (apply #(+ %1 %3) [4 5 6] ) 10 boot.user=\u003e (apply #(+ %1 %3) `[4 5 6] ) 10 boot.user=\u003e (apply #(+ %1 %3) '[4 5 6] ) 10 importing from other files… for a file \"src/lesson_two/dynamo.clj\" , use will let the namespace in it referred to as db\nboot.user=\u003e (load-file \"src/lesson_two/dynamo.clj\") #'lesson-two.dynamo/get-prime boot.user=\u003e (use '[lesson-two.dynamo :as db]) nil Reload mechanism… reload after making changes if using use\nfrom http://stackoverflow.com/questions/7658981/how-to-reload-a-clojure-file-in-repl#20337925 (use 'your.namespace :reload) When using a lein repl, the above was not working for some reason, but this pattern worked for me…\npull up a REPL..\napp.core=\u003e (require '[app.core :as mycore]) app.core=\u003e (mycore/blah \"hi\") edit code …\nthen in the REPL…\napp.core=\u003e (require '[app.core] :reload) nil app.core=\u003e (mycore/blah \"hi\") and mycore/blah is available after the reload with any changes taking effect.\nbut also this was also good , reload-all … not sure about the difference definitively\n(require 'app.core :reload-all) Also, for the namespace the repl itself is in, this worked to reload that..\n(use 'app.core :reload-all) interesting way of checking types in a hash map throw error if wrong type\nboot.user=\u003e (def steve {:name \"Steve\", :age 24, :salary 7886, :company \"Acme\"}) #'boot.user/steve boot.user=\u003e boot.user=\u003e steve {:name \"Steve\", :age 24, :salary 7886, :company \"Acme\"} boot.user=\u003e boot.user=\u003e (-\u003e steve :age num) 24 boot.user=\u003e (-\u003e steve :company num) java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number boot.user=\u003e (-\u003e steve :company str) \"Acme\" string splitting requires an import\nboot.user=\u003e (use '[clojure.string :only (split triml)]) nil boot.user=\u003e (split \"blarmey ; klarg ; jlarf ; mlarg\" #\";\") [\"blarmey \" \" klarg \" \" jlarf \" \" mlarg\"] and trimming white space and beginning, end of a string,\nboot.user=\u003e (clojure.string/trim \" a sdfd \") \"a sdfd\" Exception handling casting exception\nboot.user=\u003e steve {:name \"Steve\", :age 24, :salary 7886, :company \"Acme\"} boot.user=\u003e (try (-\u003e steve :company num) (catch java.lang.ClassCastException ex \"nope\")) \"nope\" useful technique for capturing problems with the NullPointerException. Sometimes I will get one without explanation…\nfrom, https://stackoverflow.com/questions/10529063/getting-clojure-stacktrace\nusing … clojure.repl.pst\nuser=\u003e (try (/ 1 0) (catch Exception e (pst e))) ArithmeticException Divide by zero clojure.lang.Numbers.divide (Numbers.java:156) clojure.lang.Numbers.divide (Numbers.java:3691) user/eval28 (NO_SOURCE_FILE:8) clojure.lang.Compiler.eval (Compiler.java:6511) clojure.lang.Compiler.eval (Compiler.java:6477) clojure.core/eval (core.clj:2797) clojure.main/repl/read-eval-print--6569 (main.clj:245) clojure.main/repl/fn--6574 (main.clj:266) clojure.main/repl (main.clj:266) clojure.main/repl-opt (main.clj:332) clojure.main/main (main.clj:427) clojure.lang.Var.invoke (Var.java:423) Another Exception handling and or tracing technique, using org.clojure/tools.trace user=\u003e (dotrace [list?] #_=\u003e (do #_=\u003e (list? []) #_=\u003e (list? '(1 2 3)) #_=\u003e (list?) #_=\u003e (list? (defn f [] (do ()))) #_=\u003e (list? \"a\")) #_=\u003e ) IllegalStateException Can't dynamically bind non-dynamic var: clojure.core/list? clojure.lang.Var.pushThreadBindings (Var.java:353) , user=\u003e (dotrace [list?] #_=\u003e (do #_=\u003e (list? []) #_=\u003e (list? '(1 2 3)) #_=\u003e (list?) #_=\u003e (list? (defn f [] (do ()))) #_=\u003e (list? \"a\"))) TRACE t1216: (list? []) TRACE t1216: =\u003e false TRACE t1217: (list? (1 2 3)) TRACE t1217: =\u003e true TRACE t1218: (list?) ArityException Wrong number of args (0) passed to: core$list-QMARK- clojure.lang.AFn.throwArity (AFn.java:437) The arrow -\u003e this example says it all.\n(def c 5) ;; =\u003e #'user/c (-\u003e c (+ 3) (/ 2) (- 1)) ;; =\u003e 3 ;; and if you are curious why (use 'clojure.walk) ;; =\u003e nil (macroexpand-all '(-\u003e c (+ 3) (/ 2) (- 1))) ;; =\u003e (- (/ (+ c 3) 2) 1) The -\u003e\u003e is also used. Have not yet differentiated between the two.\nvectors and lists with a vector, like [\"a\" \"b\" \"c\"], you can index, like\nboot.user=\u003e ([\"a\" \"b\" \"c\"] 1) \"b\" but apparently, vectors are difficult to modify.\nWhereas , a list '(1 2 3) can have easier appending, but it is harder to index. nth on a list will be a O(n) operation as opposed to O(1) on a vector.\n(nth (list 1 2 3 4 5) 3) reference: http://stackoverflow.com/a/11505188/472876\nAlso..\n“Lists logically grow at the head, while vectors logically grow on the tail. You can see this in action when using the conj function. It will grow the collection according to the type of collection given to it. While you can grow collections on either side, it is performant to do so in this way.”\ngroup by , wow this is cool just like what you expect from a standard group-by, and works out of the box, http://stackoverflow.com/a/9089403/472876\n(group-by #(select-keys % [:a :b]) vector-of-hashes) and a group-by followed by an aggregate, good example, http://stackoverflow.com/questions/36139680/clojure-aggregate-and-count-in-maps http://stackoverflow.com/a/36140333/472876\nthis particular example has a hash map in DATA like [ { \"a\": \"X\", \"b\": \"M\", \"c\": 188 }, { \"a\": \"Y\", \"b\": \"M\", \"c\": 165 }, { \"a\": \"Y\", \"b\": \"M\", \"c\": 313 }, { \"a\": \"Y\", \"b\": \"P\", \"c\": 188 } ] and uses a basic count, but any kind of reduce style func can be applied. (into {} (map ; f (fn [ [k vs] ] ;[k `unique count`] [k (count (into #{} (map #(get % \"b\") vs)))]) ; coll (group-by #(get % \"a\") DATA))) frequencies is like the pythonic collections.Counter Get counts nicely. nice way to extract partial hash map , based on keys using something that reminds me of perl for some reason,\nboot.user=\u003e (def h {:time-length 15N, :core-category \"work\", :project-identifier \"proj-1\", :sub-category \"code\"} ) boot.user=\u003e ( #(select-keys % [:core-category :project-identifier]) h) {:core-category \"work\", :project-identifier \"proj-1\"} was missing this … take a few items at a time with partition, Strange detail about clojure repl , namespaces and filenames, looks like namespaces with hypens, expect clojure files with underscores, My file is one/date-utils.clj and I tried to use it like so, but I got this message. boot.user=\u003e (use '[one.date-utils :as mydateutils]) java.io.FileNotFoundException: Could not locate one/date_utils__init.class or one/date_utils.clj on classpath. Please check that namespaces with dashes use underscores in the Clojure file name. boot.user=\u003e Then i changed the file to one/date_utils.clj and problem solved. boot.user=\u003e (use '[one.date-utils :as mydateutils]) nil concat vs using concat with apply As the docs https://www.conj.io/store/v1/org.clojure/clojure/1.8.0/clj/clojure.core/concat make note of, using just concat does not always have the intuitive behavior, boot.user=\u003e (concat [[5 6 7] [2 1 2]]) ([5 6 7] [2 1 2]) boot.user=\u003e (apply concat [[5 6 7] [2 1 2]]) (5 6 7 2 1 2) boot.user=\u003e Basically concat takes sequences, and not a sequence of sequences And (apply f args) has the power to take a sequence args and hand its individual components to f as bare parameters. The first example was initially unintuitive, because I was trying to concat the output of a map, (def full-list (concat (map (fn [x] (blah x)) input-vector))) that was not working, and so i needed to update w/ an apply, (def full-list (apply concat (map (fn [x] (blah x)) input-vector))) Similarly to concat, conj can be used with apply in the same way… app.core=\u003e (def vec [0 1 2 3 4]) #'app.core/vec app.core=\u003e (apply conj vec [99 88]) [0 1 2 3 4 99 88] So to explain the above, the normal form for conj is actually (conj vec 99 88), but if we have those args as a vector [99 88] then we can use apply to make the args vector be presented to conj as args. doseq and for from … https://stackoverflow.com/a/4725502/472876 The difference is that for builds a lazy sequence and returns it while doseq is for executing side-effects and returns nil. user=\u003e (for [x [1 2 3]] (+ x 5)) (6 7 8) user=\u003e (doseq [x [1 2 3]] (+ x 5)) nil user=\u003e (doseq [x [1 2 3]] (println x)) 1 2 3 nil If you want to build a new sequence based on other sequences, use for. If you want to do side-effects (printing, writing to a database, launching a nuclear warhead, etc) based on elements from some sequences, use doseq. Feels like comp is one of the identities of clojure in that it helps keep you using simple functions The order of operations is just like in maths … (fºgºh)(x) := f(g(h(x))) play.core=\u003e ((comp #(- 4 %) #(* % 9) #(+ % 95)) 5) -896 Another way to combine , merge maps.. This feels like a very particular solution playsync.core=\u003e (def m1 {:foo 1 :boo 0}) #'playsync.core/m1 playsync.core=\u003e (def m2 {:foo 2 :yoo 0}) #'playsync.core/m2 playsync.core=\u003e playsync.core=\u003e (merge-with + m1 m2) {:foo 3, :boo 0, :yoo 0} ","wordCount":"1908","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Michal Piekarczyk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://michal.piekarczyk.xyz/handy/clojure/clojure_tips/"},"publisher":{"@type":"Organization","name":"michal.piekarczyk.xyz","logo":{"@type":"ImageObject","url":"https://michal.piekarczyk.xyz/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://michal.piekarczyk.xyz/ accesskey=h title="michal.piekarczyk.xyz (Alt + H)">michal.piekarczyk.xyz</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://michal.piekarczyk.xyz/post/ title=posts><span>posts</span></a></li><li><a href=https://michal.piekarczyk.xyz/project/ title=projects><span>projects</span></a></li><li><a href=https://michal.piekarczyk.xyz/handy/ title=handy><span>handy</span></a></li><li><a href=https://michal.piekarczyk.xyz/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://michal.piekarczyk.xyz/about/ title=about><span>about</span></a></li><li><a href=https://world.hey.com/michal.piekarczyk title=frivolity><span>frivolity</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://michal.piekarczyk.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://michal.piekarczyk.xyz/handy/>Handies</a></div><h1 class=post-title></h1><div class=post-meta>9 min&nbsp;·&nbsp;1908 words&nbsp;·&nbsp;Michal Piekarczyk</div></header><div class=post-content><p>(Porting over my notes from gists .. <a href=https://gist.github.com/namoopsoo/607f29e923ceaba890588e69293413cf>here</a> ),..</p><h3 id=quick-note-on-imports>quick note on imports<a hidden class=anchor aria-hidden=true href=#quick-note-on-imports>#</a></h3><ul><li>i originally inferred this</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>ns </span>blah-namespace
</span></span><span style=display:flex><span>  (<span style=color:#e6db74>:use</span> clojure.core.blah )  <span style=color:#75715e>; this would take all the terms in blah and put them into the current namespace</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  (<span style=color:#e6db74>:refer-clojure</span> <span style=color:#e6db74>:exclude</span> [blarg flarg]) <span style=color:#75715e>; but this is supposed to be a way to avoid term clash</span>
</span></span><span style=display:flex><span>                                          <span style=color:#75715e>; so blarg and flarg will not be used. (not that they are in clojure.core however)</span>
</span></span><span style=display:flex><span>  )
</span></span></code></pre></div><ul><li>Then I read <a href=https://www.braveclojure.com/organization/#Anchor-3>https://www.braveclojure.com/organization/#Anchor-3</a> , and read <code>use</code> is a shortcut
for <code>require</code> followed by a <code>refer</code>.</li></ul><h3 id=hash-maps>hash-maps<a hidden class=anchor aria-hidden=true href=#hash-maps>#</a></h3><ul><li><p>Many ways to make a hash-map,</p><pre tabindex=0><code>; These are both fine
boot.user=&gt; {:name &#34;Steve&#34; :age 24 :salary 7886 :company &#34;Acme&#34;}
{:name &#34;Steve&#34;, :age 24, :salary 7886, :company &#34;Acme&#34;}
boot.user=&gt; {:name &#34;Steve&#34;, :age 24, :salary 7886, :company &#34;Acme&#34;}
{:name &#34;Steve&#34;, :age 24, :salary 7886, :company &#34;Acme&#34;}
</code></pre></li><li><p>how to get a value from the hash-map&mldr;</p><pre tabindex=0><code>boot.user=&gt; (steve &#34;age&#34;)  ; no
nil
boot.user=&gt; (steve 24) ; no. not even sure what this is trying to do
nil
boot.user=&gt; (steve :company) ; yes
&#34;Acme&#34;
boot.user=&gt; (steve :name) ; yes
&#34;Steve&#34;
</code></pre></li><li><p>what is insane is that this is also legal&mldr; and I see this one used more often:</p><pre tabindex=0><code>boot.user=&gt; (:name steve)
&#34;Steve&#34;
</code></pre></li><li><p>and <code>get</code> too..</p><pre tabindex=0><code>boot.user=&gt; (get steve :company)
&#34;Acme&#34;
</code></pre></li><li><p>accessing nested hashes&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>app.core=&gt; (<span style=color:#a6e22e>get-in</span> {<span style=color:#e6db74>:foo</span> {<span style=color:#e6db74>:and</span> <span style=color:#e6db74>&#34;yes&#34;</span> <span style=color:#e6db74>:here</span> <span style=color:#e6db74>&#34;no&#34;</span>}} [<span style=color:#e6db74>:foo</span> <span style=color:#e6db74>:here</span>])
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;no&#34;</span>
</span></span></code></pre></div></li></ul><h3 id=array-things>Array things<a hidden class=anchor aria-hidden=true href=#array-things>#</a></h3><ul><li><p>similarly can index arrays like hash-maps&mldr;</p><pre tabindex=0><code>  boot.user=&gt; (def a1 [1 2 3 4])
  #&#39;boot.user/a1
  boot.user=&gt; a1
  [1 2 3 4]
  boot.user=&gt; (first a1)
  1
</code></pre></li></ul><h3 id=boot-repl>Boot-repl<a hidden class=anchor aria-hidden=true href=#boot-repl>#</a></h3><ul><li><p>According to <a href=https://github.com/boot-clj/boot>https://github.com/boot-clj/boot</a> , you can set environmental variables &mldr;</p><pre tabindex=0><code>boot.user=&gt; (set-env! 
     #_=&gt;   :resource-paths #{&#34;src&#34;}
     #_=&gt;   :dependencies &#39;[[me.raynes/conch &#34;0.8.0&#34;]])
</code></pre></li><li><p>but this is not working for me or at least not for the REPL i&rsquo;m in,</p><pre tabindex=0><code>boot.user=&gt; (:development env)
nil
boot.user=&gt; (set-env!
       #_=&gt; :development true)
nil
boot.user=&gt; 

boot.user=&gt; (:development env)
nil
</code></pre></li><li><p>And to look at one or more of what is in <code>env</code></p><pre tabindex=0><code>boot.user=&gt; (use &#39;[environ.core :as env])
nil

; now you can look at anything with 
boot.user=&gt; (env :term)
&#34;xterm-256color&#34;
</code></pre><ul><li>and clojure re-writes envrironmental variables, changing <code>CAPITAL_LETTERS</code> into <code>capital-letters</code>,</li><li>so if on shell one did <code>export CAPITAL_LETTERS=bingo</code></li><li>Then <code>environ.core</code> could get this with <code>(env :capital-letters)</code></li></ul></li></ul><h3 id=lambda-functions-in-clojure--aka-anonymous-functions>lambda functions in clojure ( aka anonymous functions)<a hidden class=anchor aria-hidden=true href=#lambda-functions-in-clojure--aka-anonymous-functions>#</a></h3><ul><li><p>the <code>#(...)</code></p><pre tabindex=0><code>boot.user=&gt; (#(+ %1 5) 2)
7
boot.user=&gt; (#(+ %1 5) 2 3)

clojure.lang.ArityException: Wrong number of args (2) passed to: user/eval5691/fn--5692
boot.user=&gt; (#(+ %1 5 %2) 2 3)
10
</code></pre></li><li><p>actually, another nicer looking lambda form. I like this more..</p><pre tabindex=0><code>boot.user=&gt; (map (fn [x] (x :name)) [{:name &#34;Jo&#34;},{:name &#34;Jane&#34;},{:hmm &#34;Yea&#34;}])
(&#34;Jo&#34; &#34;Jane&#34; nil)
boot.user=&gt; 
</code></pre></li><li><p>anonymous func approach to collecting keys from hash&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>app.core=&gt; ((<span style=color:#66d9ef>fn </span>[{<span style=color:#e6db74>:keys</span> [status error]}] (println status error)) {<span style=color:#e6db74>:status</span> <span style=color:#ae81ff>400</span> <span style=color:#e6db74>:error</span> false})
</span></span><span style=display:flex><span><span style=color:#ae81ff>400</span> false
</span></span><span style=display:flex><span>nil
</span></span></code></pre></div></li></ul><h3 id=another-note-on-conj-and-hashes>Another note on <code>conj</code> and hashes&mldr;<a hidden class=anchor aria-hidden=true href=#another-note-on-conj-and-hashes>#</a></h3><ul><li>conj hashes,</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>app.core=&gt; (<span style=color:#66d9ef>def </span>blah {<span style=color:#e6db74>&#34;acc&#34;</span> <span style=color:#e6db74>&#34;123&#34;</span>})
</span></span><span style=display:flex><span><span style=color:#f92672>#</span><span style=color:#e6db74>&#39;app.core/blah</span>
</span></span><span style=display:flex><span>app.core=&gt; blah
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#34;acc&#34;</span> <span style=color:#e6db74>&#34;123&#34;</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.core=&gt; (conj blah {<span style=color:#e6db74>&#34;secret&#34;</span> <span style=color:#e6db74>&#34;455&#34;</span>})
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#34;acc&#34;</span> <span style=color:#e6db74>&#34;123&#34;</span>, <span style=color:#e6db74>&#34;secret&#34;</span> <span style=color:#e6db74>&#34;455&#34;</span>}
</span></span><span style=display:flex><span>app.core=&gt; (conj blah {<span style=color:#e6db74>&#34;secret&#34;</span> <span style=color:#e6db74>&#34;455&#34;</span> <span style=color:#e6db74>&#34;client_id&#34;</span> <span style=color:#e6db74>&#34;5667&#34;</span>})
</span></span><span style=display:flex><span>{<span style=color:#e6db74>&#34;acc&#34;</span> <span style=color:#e6db74>&#34;123&#34;</span>, <span style=color:#e6db74>&#34;secret&#34;</span> <span style=color:#e6db74>&#34;455&#34;</span>, <span style=color:#e6db74>&#34;client_id&#34;</span> <span style=color:#e6db74>&#34;5667&#34;</span>}
</span></span></code></pre></div><h3 id=a-weird-way-of-calling-a-func-using-apply-and-some-strange-dereferencing-thing->a weird way of calling a func using <code>apply</code>, and some strange dereferencing thing ,<a hidden class=anchor aria-hidden=true href=#a-weird-way-of-calling-a-func-using-apply-and-some-strange-dereferencing-thing->#</a></h3><ul><li><p>Best quote about <code>apply</code> i read is &mldr;</p><blockquote><p>apply is used to apply an operator to its operands.</p></blockquote></li><li><p>so <code>apply</code> takes a <code>func</code> as its first arg and then throws whatever is next , 1 or more args, to <code>func</code>.</p></li><li><p>I Guess that&rsquo;s a lie, because the thing is though, you want to give <code>func</code> a list thing.</p><pre tabindex=0><code>boot.user=&gt; (max 1 2 3 4 )
4
boot.user=&gt; (apply #(+  %1 %3) &#39;[4 5 6 ])
10
</code></pre></li><li><p>but all of these forms seem to work which is weird</p><pre tabindex=0><code>boot.user=&gt; (apply #(+  %1 %3) [4 5 6] )
10
boot.user=&gt; (apply #(+  %1 %3) `[4 5 6] )
10
boot.user=&gt; (apply #(+  %1 %3) &#39;[4 5 6] )
10
</code></pre></li></ul><h3 id=importing-from-other-files>importing from other files&mldr;<a hidden class=anchor aria-hidden=true href=#importing-from-other-files>#</a></h3><ul><li><p>for a file <code>"src/lesson_two/dynamo.clj"</code> , <code>use</code> will let the namespace in it referred to as <code>db</code></p><pre tabindex=0><code>boot.user=&gt; (load-file &#34;src/lesson_two/dynamo.clj&#34;)
#&#39;lesson-two.dynamo/get-prime
boot.user=&gt; (use &#39;[lesson-two.dynamo :as db])
nil
</code></pre></li></ul><h3 id=reload-mechanism>Reload mechanism&mldr;<a hidden class=anchor aria-hidden=true href=#reload-mechanism>#</a></h3><ul><li><p>reload after making changes if using <code>use</code></p><ul><li>from <a href=http://stackoverflow.com/questions/7658981/how-to-reload-a-clojure-file-in-repl#20337925>http://stackoverflow.com/questions/7658981/how-to-reload-a-clojure-file-in-repl#20337925</a></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>use</span> <span style=color:#e6db74>&#39;your.namespace</span> <span style=color:#e6db74>:reload</span>)
</span></span></code></pre></div></li><li><p>When using a <code>lein repl</code>, the above was not working for some reason, but this pattern worked for me&mldr;</p><ul><li><p>pull up a REPL..</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>app.core=&gt; (<span style=color:#a6e22e>require</span> <span style=color:#f92672>&#39;</span>[app.core <span style=color:#e6db74>:as</span> mycore])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.core=&gt; (<span style=color:#a6e22e>mycore/blah</span> <span style=color:#e6db74>&#34;hi&#34;</span>)
</span></span></code></pre></div></li><li><p>edit code &mldr;</p></li><li><p>then in the REPL&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>app.core=&gt; (<span style=color:#a6e22e>require</span> <span style=color:#f92672>&#39;</span>[app.core] <span style=color:#e6db74>:reload</span>)
</span></span><span style=display:flex><span>nil
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.core=&gt; (<span style=color:#a6e22e>mycore/blah</span> <span style=color:#e6db74>&#34;hi&#34;</span>)
</span></span></code></pre></div></li><li><p>and <code>mycore/blah</code> is available after the <em>reload</em> with any changes taking effect.</p></li><li><p>but also this was also good , <code>reload-all</code> &mldr; not sure about the difference definitively</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>require</span> <span style=color:#e6db74>&#39;app.core</span> <span style=color:#e6db74>:reload-all</span>)
</span></span></code></pre></div></li></ul></li><li><p>Also, for the namespace the <em>repl</em> itself is in, this worked to reload that..</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>use</span> <span style=color:#e6db74>&#39;app.core</span> <span style=color:#e6db74>:reload-all</span>)
</span></span></code></pre></div></li></ul><h3 id=interesting-way-of-checking-types-in-a-hash-map>interesting way of checking types in a hash map<a hidden class=anchor aria-hidden=true href=#interesting-way-of-checking-types-in-a-hash-map>#</a></h3><ul><li><p>throw error if wrong type</p><pre tabindex=0><code>boot.user=&gt; (def steve {:name &#34;Steve&#34;, :age 24, :salary 7886, :company &#34;Acme&#34;})
#&#39;boot.user/steve
boot.user=&gt; 

boot.user=&gt; steve
{:name &#34;Steve&#34;, :age 24, :salary 7886, :company &#34;Acme&#34;}
boot.user=&gt; 

boot.user=&gt; (-&gt; steve :age num)
24
boot.user=&gt; (-&gt; steve :company num)

java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number

boot.user=&gt; (-&gt; steve :company str)
&#34;Acme&#34;
</code></pre></li></ul><h3 id=string-splitting>string splitting<a hidden class=anchor aria-hidden=true href=#string-splitting>#</a></h3><ul><li><p>requires an import</p><pre tabindex=0><code>boot.user=&gt; (use &#39;[clojure.string :only (split triml)])
nil
boot.user=&gt; (split &#34;blarmey ; klarg ; jlarf ; mlarg&#34; #&#34;;&#34;)
[&#34;blarmey &#34; &#34; klarg &#34; &#34; jlarf &#34; &#34; mlarg&#34;]
</code></pre></li><li><p>and trimming white space and beginning, end of a string,</p><pre tabindex=0><code>boot.user=&gt; (clojure.string/trim &#34; a sdfd &#34;)
&#34;a sdfd&#34;
</code></pre></li></ul><h3 id=exception-handling>Exception handling<a hidden class=anchor aria-hidden=true href=#exception-handling>#</a></h3><ul><li><p>casting exception</p><pre tabindex=0><code>boot.user=&gt; steve
{:name &#34;Steve&#34;, :age 24, :salary 7886, :company &#34;Acme&#34;}
boot.user=&gt; (try (-&gt; steve :company num) (catch java.lang.ClassCastException ex &#34;nope&#34;))
&#34;nope&#34;
</code></pre></li><li><p>useful technique for capturing problems with the <code>NullPointerException</code>. Sometimes I will get one without explanation&mldr;</p></li><li><p>from, <a href=https://stackoverflow.com/questions/10529063/getting-clojure-stacktrace>https://stackoverflow.com/questions/10529063/getting-clojure-stacktrace</a></p></li><li><p>using &mldr; clojure.repl.pst</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>user=&gt; (<span style=color:#a6e22e>try</span> (/ <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>0</span>) (<span style=color:#a6e22e>catch</span> Exception e (<span style=color:#a6e22e>pst</span> e)))
</span></span><span style=display:flex><span>ArithmeticException Divide by zero
</span></span><span style=display:flex><span>    clojure.lang.Numbers.divide (<span style=color:#a6e22e>Numbers.java</span><span style=color:#e6db74>:156</span>)
</span></span><span style=display:flex><span>    clojure.lang.Numbers.divide (<span style=color:#a6e22e>Numbers.java</span><span style=color:#e6db74>:3691</span>)
</span></span><span style=display:flex><span>    user/eval28 (<span style=color:#a6e22e>NO_SOURCE_FILE</span><span style=color:#e6db74>:8</span>)
</span></span><span style=display:flex><span>    clojure.lang.Compiler.eval (<span style=color:#a6e22e>Compiler.java</span><span style=color:#e6db74>:6511</span>)
</span></span><span style=display:flex><span>    clojure.lang.Compiler.eval (<span style=color:#a6e22e>Compiler.java</span><span style=color:#e6db74>:6477</span>)
</span></span><span style=display:flex><span>    clojure.core/eval (<span style=color:#a6e22e>core.clj</span><span style=color:#e6db74>:2797</span>)
</span></span><span style=display:flex><span>    clojure.main/repl/read-eval-print--6569 (<span style=color:#a6e22e>main.clj</span><span style=color:#e6db74>:245</span>)
</span></span><span style=display:flex><span>    clojure.main/repl/fn--6574 (<span style=color:#a6e22e>main.clj</span><span style=color:#e6db74>:266</span>)
</span></span><span style=display:flex><span>    clojure.main/repl (<span style=color:#a6e22e>main.clj</span><span style=color:#e6db74>:266</span>)
</span></span><span style=display:flex><span>    clojure.main/repl-opt (<span style=color:#a6e22e>main.clj</span><span style=color:#e6db74>:332</span>)
</span></span><span style=display:flex><span>    clojure.main/main (<span style=color:#a6e22e>main.clj</span><span style=color:#e6db74>:427</span>)
</span></span><span style=display:flex><span>    clojure.lang.Var.invoke (<span style=color:#a6e22e>Var.java</span><span style=color:#e6db74>:423</span>)
</span></span></code></pre></div><h3 id=another-exception-handling-and-or-tracing-technique>Another Exception handling and or tracing technique,<a hidden class=anchor aria-hidden=true href=#another-exception-handling-and-or-tracing-technique>#</a></h3><ul><li>using <code>org.clojure/tools.trace</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>user=&gt; (<span style=color:#a6e22e>dotrace</span> [list?]
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt; (<span style=color:#a6e22e>do</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;  (<span style=color:#a6e22e>list?</span> [])
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;  (<span style=color:#a6e22e>list?</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;  (<span style=color:#a6e22e>list?</span>)
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;  (<span style=color:#a6e22e>list?</span> (<span style=color:#66d9ef>defn </span>f [] (<span style=color:#66d9ef>do </span>())))
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;  (<span style=color:#a6e22e>list?</span> <span style=color:#e6db74>&#34;a&#34;</span>))
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt; )
</span></span><span style=display:flex><span>IllegalStateException Can<span style=color:#e6db74>&#39;t</span> dynamically bind non-dynamic var<span style=color:#960050;background-color:#1e0010>:</span> clojure.core/list?
</span></span><span style=display:flex><span>  clojure.lang.Var.pushThreadBindings (<span style=color:#a6e22e>Var.java</span><span style=color:#e6db74>:353</span>)
</span></span></code></pre></div><ul><li>,</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>user=&gt; (<span style=color:#a6e22e>dotrace</span> [list?]
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;   (<span style=color:#a6e22e>do</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;   (<span style=color:#a6e22e>list?</span> [])
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;   (<span style=color:#a6e22e>list?</span> <span style=color:#f92672>&#39;</span>(<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;   (<span style=color:#a6e22e>list?</span>)
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;   (<span style=color:#a6e22e>list?</span> (<span style=color:#66d9ef>defn </span>f [] (<span style=color:#66d9ef>do </span>())))
</span></span><span style=display:flex><span>  <span style=color:#f92672>#</span>_=&gt;   (<span style=color:#a6e22e>list?</span> <span style=color:#e6db74>&#34;a&#34;</span>)))
</span></span><span style=display:flex><span>TRACE t1216<span style=color:#960050;background-color:#1e0010>:</span> (<span style=color:#a6e22e>list?</span> [])
</span></span><span style=display:flex><span>TRACE t1216<span style=color:#960050;background-color:#1e0010>:</span> =&gt; false
</span></span><span style=display:flex><span>TRACE t1217<span style=color:#960050;background-color:#1e0010>:</span> (<span style=color:#a6e22e>list?</span> (<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>TRACE t1217<span style=color:#960050;background-color:#1e0010>:</span> =&gt; true
</span></span><span style=display:flex><span>TRACE t1218<span style=color:#960050;background-color:#1e0010>:</span> (<span style=color:#a6e22e>list?</span>)
</span></span><span style=display:flex><span>ArityException Wrong number of args (<span style=color:#ae81ff>0</span>) passed to<span style=color:#960050;background-color:#1e0010>:</span> core$list-QMARK-  
</span></span><span style=display:flex><span>  clojure.lang.AFn.throwArity (<span style=color:#a6e22e>AFn.java</span><span style=color:#e6db74>:437</span>)
</span></span></code></pre></div><h3 id=the-arrow-->The arrow <code>-></code><a hidden class=anchor aria-hidden=true href=#the-arrow-->#</a></h3><ul><li><p>this example says it all.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>def </span>c <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>;; =&gt; #&#39;user/c</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(-&gt; c (+ <span style=color:#ae81ff>3</span>) (/ <span style=color:#ae81ff>2</span>) (- <span style=color:#ae81ff>1</span>))                          
</span></span><span style=display:flex><span><span style=color:#75715e>;; =&gt; 3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; and if you are curious why</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>use</span> <span style=color:#e6db74>&#39;clojure.walk</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>;; =&gt; nil</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>macroexpand-all</span> <span style=color:#f92672>&#39;</span>(-&gt; c (+ <span style=color:#ae81ff>3</span>) (/ <span style=color:#ae81ff>2</span>) (- <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span><span style=color:#75715e>;; =&gt; (- (/ (+ c 3) 2) 1)</span>
</span></span></code></pre></div></li><li><p>The <code>->></code> is also used. Have not yet differentiated between the two.</p></li></ul><h3 id=vectors-and-lists>vectors and lists<a hidden class=anchor aria-hidden=true href=#vectors-and-lists>#</a></h3><ul><li><p>with a vector, like <code>["a" "b" "c"]</code>, you can index, like</p><pre tabindex=0><code>boot.user=&gt; ([&#34;a&#34; &#34;b&#34; &#34;c&#34;] 1)
&#34;b&#34;
</code></pre></li><li><p>but apparently, vectors are difficult to modify.</p></li><li><p>Whereas , a list <code>'(1 2 3)</code> can have easier appending, but it is harder to index. <code>nth</code> on a list will be a <code>O(n)</code> operation as opposed to <code>O(1)</code> on a vector.</p><pre tabindex=0><code>(nth (list 1 2 3 4 5) 3)
</code></pre></li><li><p>reference: <a href=http://stackoverflow.com/a/11505188/472876>http://stackoverflow.com/a/11505188/472876</a></p></li><li><p>Also..</p><blockquote><p>&ldquo;Lists logically grow at the head, while vectors logically grow on the tail. You can see this in action when using the conj function. It will grow the collection according to the type of collection given to it. While you can grow collections on either side, it is performant to do so in this way.&rdquo;</p></blockquote></li></ul><h3 id=group-by--wow-this-is-cool>group by , wow this is cool<a hidden class=anchor aria-hidden=true href=#group-by--wow-this-is-cool>#</a></h3><ul><li><p>just like what you expect from a standard <code>group-by</code>, and works out of the box, <a href=http://stackoverflow.com/a/9089403/472876>http://stackoverflow.com/a/9089403/472876</a></p><pre tabindex=0><code>(group-by #(select-keys % [:a :b]) vector-of-hashes)
</code></pre></li><li><p>and a group-by followed by an aggregate, good example, <a href=http://stackoverflow.com/questions/36139680/clojure-aggregate-and-count-in-maps>http://stackoverflow.com/questions/36139680/clojure-aggregate-and-count-in-maps</a>
<a href=http://stackoverflow.com/a/36140333/472876>http://stackoverflow.com/a/36140333/472876</a></p><ul><li>this particular example has a hash map in <code>DATA</code> like</li></ul><pre tabindex=0><code>[
  {
    &#34;a&#34;: &#34;X&#34;,
    &#34;b&#34;: &#34;M&#34;,
    &#34;c&#34;: 188
  },
  {
    &#34;a&#34;: &#34;Y&#34;,
    &#34;b&#34;: &#34;M&#34;,
    &#34;c&#34;: 165
  },
  {
    &#34;a&#34;: &#34;Y&#34;,
    &#34;b&#34;: &#34;M&#34;,
    &#34;c&#34;: 313
  },
  {
    &#34;a&#34;: &#34;Y&#34;,
    &#34;b&#34;: &#34;P&#34;,
    &#34;c&#34;: 188
  }
]
</code></pre><ul><li>and uses a basic <code>count</code>, but any kind of <code>reduce</code> style func can be applied.</li></ul><pre tabindex=0><code>(into {}
  (map       

    ; f       
    (fn [ [k vs] ] ;[k `unique count`]
      [k (count (into #{} (map #(get % &#34;b&#34;) vs)))]) 

    ; coll
    (group-by #(get % &#34;a&#34;) DATA)))
</code></pre></li></ul><h3 id=frequencies-is-like-the-pythonic-collectionscounter><code>frequencies</code> is like the pythonic <code>collections.Counter</code><a hidden class=anchor aria-hidden=true href=#frequencies-is-like-the-pythonic-collectionscounter>#</a></h3><ul><li>Get counts nicely.</li></ul><h3 id=nice-way-to-extract-partial-hash-map--based-on-keys>nice way to extract partial hash map , based on keys<a hidden class=anchor aria-hidden=true href=#nice-way-to-extract-partial-hash-map--based-on-keys>#</a></h3><ul><li><p>using something that reminds me of perl for some reason,</p><pre tabindex=0><code>boot.user=&gt; (def h {:time-length 15N, :core-category &#34;work&#34;, :project-identifier &#34;proj-1&#34;, :sub-category &#34;code&#34;} ) 
boot.user=&gt; ( #(select-keys % [:core-category :project-identifier]) h)
{:core-category &#34;work&#34;, :project-identifier &#34;proj-1&#34;}
</code></pre></li></ul><h3 id=was-missing-this->was missing this &mldr;<a hidden class=anchor aria-hidden=true href=#was-missing-this->#</a></h3><ul><li>take a few items at a time with <code>partition</code>,</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure></code></pre></div><h3 id=strange-detail-about-clojure-repl--namespaces-and-filenames>Strange detail about clojure repl , namespaces and filenames,<a hidden class=anchor aria-hidden=true href=#strange-detail-about-clojure-repl--namespaces-and-filenames>#</a></h3><ul><li>looks like namespaces with hypens, expect clojure files with underscores,</li><li>My file is <code>one/date-utils.clj</code> and I tried to use it like so, but I got this message.</li></ul><pre tabindex=0><code>boot.user=&gt; (use &#39;[one.date-utils :as mydateutils])

java.io.FileNotFoundException: Could not locate one/date_utils__init.class or one/date_utils.clj on classpath. Please check that namespaces with dashes use underscores in the Clojure file name.
boot.user=&gt; 
</code></pre><ul><li>Then i changed the file to <code>one/date_utils.clj</code> and problem solved.</li></ul><pre tabindex=0><code>boot.user=&gt; (use &#39;[one.date-utils :as mydateutils])
nil
</code></pre><h3 id=concat-vs-using-concat-with-apply><code>concat</code> vs using <code>concat</code> with <code>apply</code><a hidden class=anchor aria-hidden=true href=#concat-vs-using-concat-with-apply>#</a></h3><ul><li>As the docs <a href=https://www.conj.io/store/v1/org.clojure/clojure/1.8.0/clj/clojure.core/concat>https://www.conj.io/store/v1/org.clojure/clojure/1.8.0/clj/clojure.core/concat</a> make note of, using just <code>concat</code> does not always have the intuitive behavior,</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>boot.user=&gt; (concat [[<span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span>] [<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>]])
</span></span><span style=display:flex><span>([<span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span>] [<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span>boot.user=&gt; (apply concat [[<span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span>] [<span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>]])
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>5</span> <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>boot.user=&gt;
</span></span></code></pre></div><ul><li>Basically <code>concat</code> takes sequences, and not a sequence of sequences</li><li>And <code>(apply f args)</code> has the power to take a sequence <code>args</code> and hand its individual components
to <code>f</code> as bare parameters.</li><li>The first example was initially unintuitive, because I was trying to <code>concat</code> the output of a <code>map</code>,</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>def </span>full-list (<span style=color:#a6e22e>concat</span>
</span></span><span style=display:flex><span>                (map (<span style=color:#66d9ef>fn </span>[x] (<span style=color:#a6e22e>blah</span> x))
</span></span><span style=display:flex><span>                 input-vector)))
</span></span></code></pre></div><ul><li>that was not working, and so i needed to update w/ an apply,</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>def </span>full-list (apply concat
</span></span><span style=display:flex><span>                (map (<span style=color:#66d9ef>fn </span>[x] (<span style=color:#a6e22e>blah</span> x))
</span></span><span style=display:flex><span>                 input-vector)))
</span></span></code></pre></div><ul><li>Similarly to <code>concat</code>, <code>conj</code> can be used with <code>apply</code> in the same way&mldr;</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>app.core=&gt; (<span style=color:#66d9ef>def </span>vec [<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span>])
</span></span><span style=display:flex><span><span style=color:#f92672>#</span><span style=color:#e6db74>&#39;app.core/vec</span>
</span></span><span style=display:flex><span>app.core=&gt; (apply conj vec [<span style=color:#ae81ff>99</span> <span style=color:#ae81ff>88</span>])
</span></span><span style=display:flex><span>[<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>99</span> <span style=color:#ae81ff>88</span>]
</span></span></code></pre></div><ul><li>So to explain the above, the normal form for <code>conj</code> is actually <code>(conj vec 99 88)</code>,
but if we have those args as a vector <code>[99 88]</code> then we can use <code>apply</code> to make the args vector
be presented to <code>conj</code> as args.</li></ul><h3 id=doseq-and-for><code>doseq</code> and <code>for</code><a hidden class=anchor aria-hidden=true href=#doseq-and-for>#</a></h3><ul><li>from &mldr; <a href=https://stackoverflow.com/a/4725502/472876>https://stackoverflow.com/a/4725502/472876</a>
<em>The difference is that for builds a lazy sequence and returns it while doseq is for executing side-effects and returns nil.</em></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>user=&gt; (for [x [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>]] (+ x <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>(<span style=color:#ae81ff>6</span> <span style=color:#ae81ff>7</span> <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>user=&gt; (doseq [x [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>]] (+ x <span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>nil
</span></span><span style=display:flex><span>user=&gt; (doseq [x [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>]] (println x))
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>nil
</span></span></code></pre></div><ul><li><em>If you want to build a new sequence based on other sequences, use for. If you want to do side-effects (printing, writing to a database, launching a nuclear warhead, etc) based on elements from some sequences, use doseq.</em></li></ul><h3 id=feels-like-comp-is-one-of-the-identities-of-clojure-in-that-it-helps-keep-you-using-simple-functions>Feels like <code>comp</code> is one of the identities of clojure in that it helps keep you using simple functions<a hidden class=anchor aria-hidden=true href=#feels-like-comp-is-one-of-the-identities-of-clojure-in-that-it-helps-keep-you-using-simple-functions>#</a></h3><ul><li>The order of operations is just like in <em>maths</em> &mldr; <code>(fºgºh)(x) := f(g(h(x)))</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>play.core=&gt; ((comp <span style=color:#f92672>#</span>(- <span style=color:#ae81ff>4</span> %) <span style=color:#f92672>#</span>(* % <span style=color:#ae81ff>9</span>) <span style=color:#f92672>#</span>(+ % <span style=color:#ae81ff>95</span>)) <span style=color:#ae81ff>5</span>)  
</span></span><span style=display:flex><span><span style=color:#ae81ff>-896</span>
</span></span></code></pre></div><h3 id=another-way-to-combine--merge-maps>Another way to combine , merge maps..<a hidden class=anchor aria-hidden=true href=#another-way-to-combine--merge-maps>#</a></h3><ul><li>This feels like a very particular solution</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>playsync.core=&gt; (<span style=color:#66d9ef>def </span>m1 {<span style=color:#e6db74>:foo</span> <span style=color:#ae81ff>1</span> <span style=color:#e6db74>:boo</span> <span style=color:#ae81ff>0</span>})
</span></span><span style=display:flex><span><span style=color:#f92672>#</span><span style=color:#e6db74>&#39;playsync.core/m1</span>
</span></span><span style=display:flex><span>playsync.core=&gt; (<span style=color:#66d9ef>def </span>m2 {<span style=color:#e6db74>:foo</span> <span style=color:#ae81ff>2</span> <span style=color:#e6db74>:yoo</span> <span style=color:#ae81ff>0</span>})
</span></span><span style=display:flex><span><span style=color:#f92672>#</span><span style=color:#e6db74>&#39;playsync.core/m2</span>
</span></span><span style=display:flex><span>playsync.core=&gt; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>playsync.core=&gt; (merge-with + m1 m2)
</span></span><span style=display:flex><span>{<span style=color:#e6db74>:foo</span> <span style=color:#ae81ff>3</span>, <span style=color:#e6db74>:boo</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>:yoo</span> <span style=color:#ae81ff>0</span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://michal.piekarczyk.xyz/>michal.piekarczyk.xyz</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>