<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>My blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="sleeping&mldr; (Thread/sleep 4000) simple multithreading , from the Brave clojure book (future (Thread/sleep 4000) (println &#34;I'll print after 4 seconds&#34;)) (println &#34;I'll print immediately&#34;) hmm this is weird. so dereferencing the future blocks? (defn fight-crime [] (let [] (println &#34;hi&#34;) (Thread/sleep 2000) (println &#34;ho&#34;) (Thread/sleep 1000) (println &#34;yo&#34;) 5 )) (let [result (future (fight-crime))] (println &#34;@: &#34; @result) (println &#34;snore. &#34; ) (println &#34;@: &#34; @result) (Thread/sleep 1000) (println &#34;@: &#34; @result) )  Ah ok, but you can stop waiting."><meta name=generator content="Hugo 0.85.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css><meta property="og:title" content><meta property="og:description" content="sleeping&mldr; (Thread/sleep 4000) simple multithreading , from the Brave clojure book (future (Thread/sleep 4000) (println &#34;I'll print after 4 seconds&#34;)) (println &#34;I'll print immediately&#34;) hmm this is weird. so dereferencing the future blocks? (defn fight-crime [] (let [] (println &#34;hi&#34;) (Thread/sleep 2000) (println &#34;ho&#34;) (Thread/sleep 1000) (println &#34;yo&#34;) 5 )) (let [result (future (fight-crime))] (println &#34;@: &#34; @result) (println &#34;snore. &#34; ) (println &#34;@: &#34; @result) (Thread/sleep 1000) (println &#34;@: &#34; @result) )  Ah ok, but you can stop waiting."><meta property="og:type" content="article"><meta property="og:url" content="https://michal.piekarczyk.xyz/handy/clojure/futures-promises/"><meta property="article:section" content="handy"><meta property="og:site_name" content="My blog"><meta itemprop=name content><meta itemprop=description content="sleeping&mldr; (Thread/sleep 4000) simple multithreading , from the Brave clojure book (future (Thread/sleep 4000) (println &#34;I'll print after 4 seconds&#34;)) (println &#34;I'll print immediately&#34;) hmm this is weird. so dereferencing the future blocks? (defn fight-crime [] (let [] (println &#34;hi&#34;) (Thread/sleep 2000) (println &#34;ho&#34;) (Thread/sleep 1000) (println &#34;yo&#34;) 5 )) (let [result (future (fight-crime))] (println &#34;@: &#34; @result) (println &#34;snore. &#34; ) (println &#34;@: &#34; @result) (Thread/sleep 1000) (println &#34;@: &#34; @result) )  Ah ok, but you can stop waiting."><meta itemprop=wordCount content="877"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="sleeping&mldr; (Thread/sleep 4000) simple multithreading , from the Brave clojure book (future (Thread/sleep 4000) (println &#34;I'll print after 4 seconds&#34;)) (println &#34;I'll print immediately&#34;) hmm this is weird. so dereferencing the future blocks? (defn fight-crime [] (let [] (println &#34;hi&#34;) (Thread/sleep 2000) (println &#34;ho&#34;) (Thread/sleep 1000) (println &#34;yo&#34;) 5 )) (let [result (future (fight-crime))] (println &#34;@: &#34; @result) (println &#34;snore. &#34; ) (println &#34;@: &#34; @result) (Thread/sleep 1000) (println &#34;@: &#34; @result) )  Ah ok, but you can stop waiting."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">My blog</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/about/ title="About page">About</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/handy/ title="Handy page">Handy</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/post/ title="Post page">Post</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/project/ title="Side Projects page">Side Projects</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/foo/ title="The Foos page">The Foos</a></li></ul></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">HANDY</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=https://michal.piekarczyk.xyz/handy/clojure/futures-promises/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=https://michal.piekarczyk.xyz/handy/clojure/futures-promises/&text=" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://michal.piekarczyk.xyz/handy/clojure/futures-promises/&title=" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1"></h1><time class="f6 mv4 dib tracked" datetime=0001-01-01T00:00:00Z>January 1, 0001</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h3 id=sleeping>sleeping&mldr;</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>4000</span>)
</code></pre></div><h3 id=simple-multithreading---from-the-brave-clojure-book>simple multithreading , from the Brave clojure book</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#a6e22e>future</span> (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>4000</span>)
        (println <span style=color:#e6db74>&#34;I&#39;ll print after 4 seconds&#34;</span>))
(println <span style=color:#e6db74>&#34;I&#39;ll print immediately&#34;</span>)
</code></pre></div><h3 id=hmm-this-is-weird-so-dereferencing-the-future-blocks>hmm this is weird. so dereferencing the future blocks?</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>fight-crime
  []
  (<span style=color:#66d9ef>let </span>[]
  (println <span style=color:#e6db74>&#34;hi&#34;</span>)
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>2000</span>)
  (println <span style=color:#e6db74>&#34;ho&#34;</span>)
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>1000</span>)
  (println <span style=color:#e6db74>&#34;yo&#34;</span>)
  <span style=color:#ae81ff>5</span>
  ))

(<span style=color:#66d9ef>let </span>[result (<span style=color:#a6e22e>future</span> (<span style=color:#a6e22e>fight-crime</span>))]
  (println <span style=color:#e6db74>&#34;@: &#34;</span> <span style=color:#f92672>@</span>result)
  (println <span style=color:#e6db74>&#34;snore. &#34;</span> )
  (println <span style=color:#e6db74>&#34;@: &#34;</span> <span style=color:#f92672>@</span>result)
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>1000</span>)
  (println <span style=color:#e6db74>&#34;@: &#34;</span> <span style=color:#f92672>@</span>result)
)
</code></pre></div><ul><li>Ah ok, but you can stop waiting.. so here we wait <code>10ms</code> and then return &ldquo;hmmf&rdquo; if future isnt done yet.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>let </span>[result (<span style=color:#a6e22e>future</span> (<span style=color:#a6e22e>fight-crime</span>))]
  (println <span style=color:#e6db74>&#34;@: &#34;</span> (deref result <span style=color:#ae81ff>10</span> <span style=color:#e6db74>&#34;hmmf&#34;</span>))
  (println <span style=color:#e6db74>&#34;snore. &#34;</span> )
  (println <span style=color:#e6db74>&#34;@: &#34;</span> (deref result <span style=color:#ae81ff>10</span> <span style=color:#e6db74>&#34;hmmf&#34;</span>))
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>5000</span>)
  (println <span style=color:#e6db74>&#34;@: &#34;</span> (deref result <span style=color:#ae81ff>10</span> <span style=color:#e6db74>&#34;hmmf&#34;</span>))
)
</code></pre></div><h3 id=delays-cool>delays. cool</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>jackson-5-delay
  (<span style=color:#a6e22e>delay</span> (<span style=color:#66d9ef>let </span>[message <span style=color:#e6db74>&#34;Just call my name and I&#39;ll be there&#34;</span>]
           (println <span style=color:#e6db74>&#34;First deref:&#34;</span> message)
           message)))
</code></pre></div><ul><li>and a colorful example with <code>future</code>, <code>force</code>, <code>delay</code> , from <a href=http://www.braveclojure.com/concurrency/>http://www.braveclojure.com/concurrency/</a></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>gimli-headshots [<span style=color:#e6db74>&#34;serious.jpg&#34;</span> <span style=color:#e6db74>&#34;fun.jpg&#34;</span> <span style=color:#e6db74>&#34;playful.jpg&#34;</span>])
(<span style=color:#66d9ef>defn </span>email-user
  [email-address]
  (println <span style=color:#e6db74>&#34;Sending headshot notification to&#34;</span> email-address))
(<span style=color:#66d9ef>defn </span>upload-document
  <span style=color:#e6db74>&#34;Needs to be implemented&#34;</span>
  [headshot]
  true)
(<span style=color:#66d9ef>let </span>[notify (<span style=color:#a6e22e>delay</span> (<span style=color:#a6e22e>email-user</span> <span style=color:#e6db74>&#34;and-my-axe@gmail.com&#34;</span>))]
  (doseq [headshot gimli-headshots]
    (<span style=color:#a6e22e>future</span> (<span style=color:#a6e22e>upload-document</span> headshot)
            (<span style=color:#a6e22e>force</span> notify))))
</code></pre></div><h3 id=blocking-thread-in-action>Blocking thread in action&mldr;</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=color:#75715e>; make a future which blocks on a promise. Then deliver promise in main thread and see what happens.</span>
(<span style=color:#66d9ef>def </span>a-promise (<span style=color:#a6e22e>promise</span>))
(<span style=color:#66d9ef>def </span>futr
    (<span style=color:#a6e22e>future</span> 
        (<span style=color:#66d9ef>def </span>result (+ <span style=color:#f92672>@</span>a-promise <span style=color:#ae81ff>10</span>))
        (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>5000</span>)
        (println <span style=color:#e6db74>&#34;result &#34;</span> result)
        result))
<span style=color:#75715e>; </span>
(println <span style=color:#e6db74>&#34;nothing yet: &#34;</span> (deref futr <span style=color:#ae81ff>10</span> <span style=color:#e6db74>&#34;nothing.&#34;</span>))
<span style=color:#75715e>; deliver..    </span>
(<span style=color:#a6e22e>deliver</span> a-promise <span style=color:#ae81ff>99</span>)
(println <span style=color:#e6db74>&#34;right after deliverin &#34;</span> (deref futr <span style=color:#ae81ff>10</span> <span style=color:#e6db74>&#34;still nothin.&#34;</span>))
(<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>5500</span>)
(println <span style=color:#e6db74>&#34;had some time to think... &#34;</span> (deref futr))
</code></pre></div><h3 id=delivering-to-promise-multiple-times>delivering to promise multiple times?</h3><ul><li>hmm, how about the other way around&mldr; make some workers do something and have them all try deliver same promise. What will happen?</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>another-promise (<span style=color:#a6e22e>promise</span>))
(<span style=color:#66d9ef>def </span>d1 (<span style=color:#a6e22e>delay</span> 
                (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>6000</span>)
                (<span style=color:#a6e22e>deliver</span> another-promise <span style=color:#ae81ff>6000</span>)
                ))
<span style=color:#75715e>;</span>
(<span style=color:#66d9ef>def </span>d2 (<span style=color:#a6e22e>delay</span> 
                (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>4000</span>)
                (<span style=color:#a6e22e>deliver</span> another-promise <span style=color:#ae81ff>4000</span>)
                ))
<span style=color:#75715e>;</span>
(<span style=color:#66d9ef>def </span>d3 (<span style=color:#a6e22e>delay</span> 
                (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>1000</span>)
                (<span style=color:#a6e22e>deliver</span> another-promise <span style=color:#ae81ff>1000</span>)
                ))
<span style=color:#75715e>; nothing there right?</span>
(<span style=color:#a6e22e>realized?</span> another-promise)
<span style=color:#75715e>; now run them all...</span>
(doseq [a-worker [d1 d2 d3]]
        (<span style=color:#a6e22e>future</span> (<span style=color:#a6e22e>force</span> a-worker))
        )

(println <span style=color:#e6db74>&#34;Check promise: &#34;</span> (deref another-promise <span style=color:#ae81ff>10</span> <span style=color:#e6db74>&#34;nothin.&#34;</span>))
(println <span style=color:#e6db74>&#34;Check promise: &#34;</span> <span style=color:#f92672>@</span>another-promise)
</code></pre></div><ul><li>hmm, for the above, strange that I tried but was not able to <code>deref</code> the delays. Error was</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>ClassCastException clojure.lang.Delay cannot be cast to java.util.concurrent.Future  clojure.core/deref-future (<span style=color:#a6e22e>core.clj</span><span style=color:#e6db74>:2206</span>)
</code></pre></div><ul><li></li></ul><h3 id=exercise-in-httpwwwbraveclojurecomconcurrency>exercise in <a href=http://www.braveclojure.com/concurrency/>http://www.braveclojure.com/concurrency/</a></h3><ul><li>given the yak butter search data&mldr;</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>def </span>yak-butter-international
  {<span style=color:#e6db74>:store</span> <span style=color:#e6db74>&#34;Yak Butter International&#34;</span>
    <span style=color:#e6db74>:price</span> <span style=color:#ae81ff>90</span>
    <span style=color:#e6db74>:smoothness</span> <span style=color:#ae81ff>90</span>})
(<span style=color:#66d9ef>def </span>butter-than-nothing
  {<span style=color:#e6db74>:store</span> <span style=color:#e6db74>&#34;Butter Than Nothing&#34;</span>
   <span style=color:#e6db74>:price</span> <span style=color:#ae81ff>150</span>
   <span style=color:#e6db74>:smoothness</span> <span style=color:#ae81ff>83</span>})
<span style=color:#75715e>;; This is the butter that meets our requirements</span>
(<span style=color:#66d9ef>def </span>baby-got-yak
  {<span style=color:#e6db74>:store</span> <span style=color:#e6db74>&#34;Baby Got Yak&#34;</span>
   <span style=color:#e6db74>:price</span> <span style=color:#ae81ff>94</span>
   <span style=color:#e6db74>:smoothness</span> <span style=color:#ae81ff>99</span>})

(<span style=color:#66d9ef>defn </span>mock-api-call
  [result]
  (<span style=color:#a6e22e>Thread/sleep</span> <span style=color:#ae81ff>1000</span>)
  result)

(<span style=color:#66d9ef>defn </span>satisfactory?
  <span style=color:#e6db74>&#34;If the butter meets our criteria, return the butter, else return false&#34;</span>
  [butter]
  (and (&lt;= (<span style=color:#e6db74>:price</span> butter) <span style=color:#ae81ff>100</span>)
       (&gt;= (<span style=color:#e6db74>:smoothness</span> butter) <span style=color:#ae81ff>97</span>)
       butter))
</code></pre></div><ul><li>The original non concurrent code was &mldr;</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(time (some (comp satisfactory? mock-api-call)
            [yak-butter-international butter-than-nothing baby-got-yak]))
<span style=color:#75715e>; =&gt; &#34;Elapsed time: 3002.132 msecs&#34;</span>
<span style=color:#75715e>; =&gt; {:store &#34;Baby Got Yak&#34;, :smoothness 99, :price 94}</span>
</code></pre></div><ul><li>and a concurrent version&mldr;</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>blah-func
    []
    (<span style=color:#66d9ef>def </span>best-butter-promise (<span style=color:#a6e22e>promise</span>))
    (<span style=color:#a6e22e>time</span>
        (doseq [some-butter [yak-butter-international butter-than-nothing baby-got-yak]]
            (<span style=color:#a6e22e>future</span> (<span style=color:#66d9ef>if </span>((comp satisfactory? mock-api-call) some-butter)
                        (<span style=color:#a6e22e>deliver</span> best-butter-promise some-butter)
                        )))
                        )
    (<span style=color:#a6e22e>time</span>
        (println <span style=color:#e6db74>&#34;result is: &#34;</span> <span style=color:#f92672>@</span>best-butter-promise))
    )
(<span style=color:#a6e22e>blah-func</span>)

=&gt;
cloj-multiproc-play.core=&gt; (<span style=color:#a6e22e>blah-func</span>)
<span style=color:#e6db74>&#34;Elapsed time: 0.615436 msecs&#34;</span>
result is<span style=color:#960050;background-color:#1e0010>:</span>  {<span style=color:#e6db74>:store</span> Baby Got Yak, <span style=color:#e6db74>:price</span> <span style=color:#ae81ff>94</span>, <span style=color:#e6db74>:smoothness</span> <span style=color:#ae81ff>99</span>}
<span style=color:#e6db74>&#34;Elapsed time: 1001.655823 msecs&#34;</span>
nil
cloj-multiproc-play.core=&gt;
</code></pre></div><h3 id=one-more-example--racing-bing-vs-google>one more example , racing Bing vs Google</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>
(<span style=color:#66d9ef>def </span>search-result-promise (<span style=color:#a6e22e>promise</span>))

(<span style=color:#66d9ef>def </span>bingurl  <span style=color:#e6db74>&#34;https://www.bing.com/search?q=foobar&#34;</span>)

(<span style=color:#66d9ef>def </span>googleurl <span style=color:#e6db74>&#34;https://www.google.com/?gws_rd=ssl#q=foobar&#34;</span>)

(doseq [url [bingurl googleurl]]
    (<span style=color:#a6e22e>future</span> (<span style=color:#a6e22e>deliver</span> search-result-promise (slurp url)
       ))
)

(<span style=color:#66d9ef>def </span>html1 (slurp <span style=color:#e6db74>&#34;https://www.google.com/?gws_rd=ssl#q=foobar&#34;</span>))

</code></pre></div><h3 id=hot-dog-machine-from-httpwwwbraveclojurecomcore-async>hot dog machine from <a href=http://www.braveclojure.com/core-async/>http://www.braveclojure.com/core-async/</a></h3><ul><li>my version of a hot dog machine that only dispenses max number of hot dogs&mldr;</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>defn </span>hot-dog-machine-v2
  [how-many-dogs-init]
  (<span style=color:#66d9ef>let </span>[in (<span style=color:#a6e22e>chan</span>)
        out (<span style=color:#a6e22e>chan</span>)]
    (<span style=color:#a6e22e>go</span>
      (<span style=color:#66d9ef>loop </span>[num-dogs how-many-dogs-init]
        <span style=color:#75715e>; if no hot dogs left, then done.</span>
        (<span style=color:#66d9ef>if </span>(= num-dogs <span style=color:#ae81ff>0</span>)
          true
          <span style=color:#75715e>; Otherwise </span>
          (<span style=color:#a6e22e>do</span>
            (println <span style=color:#e6db74>&#34;Going to &lt;! block on &lt;in&gt; now.&#34;</span>)
            (<span style=color:#a6e22e>&lt;!</span> in)
            (println <span style=color:#e6db74>&#34;Now we have &#34;</span> num-dogs <span style=color:#e6db74>&#34; dogs.&#34;</span>)
            (println <span style=color:#e6db74>&#34;Going to &gt;! block on &lt;out&gt; now.&#34;</span>)
            (<span style=color:#a6e22e>&gt;!</span> out <span style=color:#e6db74>&#34;hot dog&#34;</span>)
            ))
        (<span style=color:#a6e22e>recur</span> (dec num-dogs))
        
        ))
    [in out]
    ))

<span style=color:#75715e>; get channels..</span>
(<span style=color:#66d9ef>def </span>machine-channels (<span style=color:#a6e22e>hot-dog-machine-v2</span> <span style=color:#ae81ff>5</span>))
(<span style=color:#66d9ef>def </span>in (first machine-channels))
(<span style=color:#66d9ef>def </span>out (last machine-channels))

<span style=color:#75715e>; ... dispensing them    </span>
(println <span style=color:#e6db74>&#34;one&#34;</span>)
(<span style=color:#a6e22e>&gt;!!</span> in <span style=color:#e6db74>&#34;pocket lint&#34;</span>)
(<span style=color:#a6e22e>&lt;!!</span> out)

(println <span style=color:#e6db74>&#34;two&#34;</span>)
(<span style=color:#a6e22e>&gt;!!</span> in <span style=color:#e6db74>&#34;pocket lint&#34;</span>)
(<span style=color:#a6e22e>&lt;!!</span> out)

(println <span style=color:#e6db74>&#34;three&#34;</span>)
(<span style=color:#a6e22e>&gt;!!</span> in <span style=color:#e6db74>&#34;pocket lint&#34;</span>)
(<span style=color:#a6e22e>&lt;!!</span> out)

(println <span style=color:#e6db74>&#34;four&#34;</span>)
(<span style=color:#a6e22e>&gt;!!</span> in <span style=color:#e6db74>&#34;pocket lint&#34;</span>)
(<span style=color:#a6e22e>&lt;!!</span> out)

(println <span style=color:#e6db74>&#34;five&#34;</span>)
(<span style=color:#a6e22e>&gt;!!</span> in <span style=color:#e6db74>&#34;pocket lint&#34;</span>)
(<span style=color:#a6e22e>&lt;!!</span> out)
....

<span style=color:#75715e>; that was fine except we went into negative hot dogs...</span>
playsync.core=&gt; (println <span style=color:#e6db74>&#34;five&#34;</span>)
five
nil
playsync.core=&gt; (<span style=color:#a6e22e>&gt;!!</span> in <span style=color:#e6db74>&#34;pocket lint&#34;</span>)
trueNow we have  <span style=color:#ae81ff>1</span>  dogs.
Going to &gt;! block on &lt;out&gt; now.

playsync.core=&gt; (<span style=color:#a6e22e>&lt;!!</span> out)
Going to &lt;! block on &lt;in&gt; now.
<span style=color:#e6db74>&#34;hot dog&#34;</span>
playsync.core=&gt; 

playsync.core=&gt; (<span style=color:#a6e22e>&gt;!!</span> in <span style=color:#e6db74>&#34;pocket lint&#34;</span>)
Now we have  <span style=color:#ae81ff>-1</span>  dogs.
true
Going to &gt;! block on &lt;out&gt; now.
playsync.core=&gt; (<span style=color:#a6e22e>&lt;!!</span> out)
<span style=color:#e6db74>&#34;hot dog&#34;</span>Going to &lt;! block on &lt;in&gt; now.

</code></pre></div><ul><li>.. update</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure>(<span style=color:#66d9ef>let </span>[results-chan (<span style=color:#a6e22e>chan</span>)
    results-vector (<span style=color:#a6e22e>atom</span> [])]
    
    <span style=color:#75715e>; For several things in stuff-vec , start some async call that will throw results,</span>
    <span style=color:#75715e>; into the results-chan</span>
    (doseq [x stuff-vec]
        (<span style=color:#a6e22e>do-something-async</span> results-chan x))
        
    <span style=color:#75715e>; in this case, we take from the results-chan once they are ready, </span>
    <span style=color:#75715e>; and update (using conj) the atom results-vector</span>
    (doseq [_ stuff-vec]
        (<span style=color:#a6e22e>swap!</span> results-vector conj (<span style=color:#a6e22e>&lt;!!</span> results-chan)))
    )
</code></pre></div><h3 id=swap-syntax-for-updating-atoms>swap syntax for updating atoms&mldr;</h3><ul><li></li></ul><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://michal.piekarczyk.xyz/>&copy; My blog 2021</a><div></div></div></footer></body></html>