<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>michal.piekarczyk.xyz</title><meta name=keywords content><meta name=description content="comparing really large spark dataframes I had this usecase where I wanted to be able to check if very large multi-million row and multi-thousand column dataframes were equal, but the advice online about using df1.subtract(df2) just was not cutting it because it was just too slow. It seems to me the df1.subtract(df2) approach more or less is a O(n^2) approach where it is necessary to compare each row in df1 with each row in df2."><meta name=author content="Michal Piekarczyk"><link rel=canonical href=https://michal.piekarczyk.xyz/handy/databricks-spark/join-merge-parquet/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://michal.piekarczyk.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://michal.piekarczyk.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://michal.piekarczyk.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://michal.piekarczyk.xyz/apple-touch-icon.png><link rel=mask-icon href=https://michal.piekarczyk.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-86TSXEXWB5"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-86TSXEXWB5",{anonymize_ip:!1})}</script><meta property="og:title" content><meta property="og:description" content="comparing really large spark dataframes I had this usecase where I wanted to be able to check if very large multi-million row and multi-thousand column dataframes were equal, but the advice online about using df1.subtract(df2) just was not cutting it because it was just too slow. It seems to me the df1.subtract(df2) approach more or less is a O(n^2) approach where it is necessary to compare each row in df1 with each row in df2."><meta property="og:type" content="article"><meta property="og:url" content="https://michal.piekarczyk.xyz/handy/databricks-spark/join-merge-parquet/"><meta property="article:section" content="handy"><meta property="og:site_name" content="michal.piekarczyk.xyz"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="comparing really large spark dataframes I had this usecase where I wanted to be able to check if very large multi-million row and multi-thousand column dataframes were equal, but the advice online about using df1.subtract(df2) just was not cutting it because it was just too slow. It seems to me the df1.subtract(df2) approach more or less is a O(n^2) approach where it is necessary to compare each row in df1 with each row in df2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Handies","item":"https://michal.piekarczyk.xyz/handy/"},{"@type":"ListItem","position":2,"name":"","item":"https://michal.piekarczyk.xyz/handy/databricks-spark/join-merge-parquet/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"comparing really large spark dataframes I had this usecase where I wanted to be able to check if very large multi-million row and multi-thousand column dataframes were equal, but the advice online about using df1.subtract(df2) just was not cutting it because it was just too slow. It seems to me the df1.subtract(df2) approach more or less is a O(n^2) approach where it is necessary to compare each row in df1 with each row in df2.","keywords":[],"articleBody":"comparing really large spark dataframes I had this usecase where I wanted to be able to check if very large multi-million row and multi-thousand column dataframes were equal, but the advice online about using df1.subtract(df2) just was not cutting it because it was just too slow. It seems to me the df1.subtract(df2) approach more or less is a O(n^2) approach where it is necessary to compare each row in df1 with each row in df2. Instead I was wondering, hey if there are known index columns in these dataframes, maybe we can cheat a little and join them first and then do the comparison after joining them.\nWhat I came up with below so far does not handle the case yet of index keys that are not common. I would like to add that at some point. And for now this also requires the schemas of the dataframes to be the same.\ndef join_compare(df1, df2, index_cols, head_n_rows=None, cache=True): # TODO fix to be outer join I think is needed? For now assumes all index cols match fully. assert_schema_equality_ignore_nullable(df1.schema, df2.schema) if head_n_rows is not None: df1 = df1.limit(head_n_rows) feature_cols = list(set(df1.columns) - set(index_cols)) which_type_names = { x.name: x.dataType.typeName() for x in df1.schema.fields if x.name not in index_cols } double_cols = [k for (k, v) in which_type_names.items() if v == \"double\"] string_cols = [k for (k, v) in which_type_names.items() if v == \"string\"] integer_cols = [k for (k, v) in which_type_names.items() if v == \"integer\"] # To find the actual doubles that are \u003c 1, calculate col means. stats_dict = dict( df1.select([f.mean(k).alias(k) for k in double_cols]) .toPandas() .to_dict(orient=\"records\")[0] ) double_cols_for_reals = [k for (k, v) in stats_dict.items() if v \u003c= 1] integer_types_double_on_paper = [k for (k, v) in stats_dict.items() if v \u003e 1] print( \"all doubles:\", len(double_cols), \", doubles for real:\", len(double_cols_for_reals), ) diff_dfs = {} double_sensitivity = 0.1 integer_condition = reduce( or_, ( [ (f.round(f.abs(f.col(f\"x.{col}\") - f.col(f\"y.{col}\"))) \u003e 0) for col in (integer_types_double_on_paper + integer_cols) ] ), ) string_condition = reduce( or_, ([(f.col(f\"x.{col}\") != f.col(f\"y.{col)\")) for col in string_cols]) ) doubles_condition = reduce( or_, ( [ (f.abs(f.col(f\"x.{col}\") - f.col(f\"y.{col)\")) \u003e double_sensitivity) for col in double_cols_for_reals ] ), ) rounded_cols = reduce( lambda x, y: x + y, [ ( f.round(f.col(f\"x.{col)\"), 2).alias(f\"x_{col}\"), f.round(f.col(f\"y.{col)\"), 2).alias(f\"y_{col}\"), ) for col in double_cols_for_reals ], ) select_integer_cols = reduce( lambda x, y: x + y, [ (f.col(f\"x.{col}\").alias(f\"y_ {col)\"), f.col(f\"y.{col}\").alias(f\"y_{col}\")) for col in (integer_types_double_on_paper + integer_cols) ], ) select_string_cols = reduce( lambda x, y: x + y, [ (f.col(f\"x.{col}\").alias(f\"x_{col}\"), f.col(f\"y.{col}\").alias(f\"y_{col}\")) for col in string_cols ], ) print(\"starting doubles_diff\") diff_dfs[\"doubles_diffdf\"] = ( df1.alias(\"x\").join(df2.alias(\"y\"), index_cols, ).where(doubles_condition).select(*index_cols, *rounded_cols) ) print(\"starting integer diff\") diff_dfs[\"integer_diffdf\"] = ( df1.alias(\"x\").join(df2.alias(\"y\"), index_cols, ).where(integer_condition).select( *index_cols, *select_integer_cols) ) print(\"starting string diff\") diff_dfs[\"string_diffdf\"] = ( df1.alias(\"x\").join(df2.alias(\"y\"), index_cols, ).where(string_condition).select(*index_cols, *select_string_cols) ) if cache: print(\"caching\") for k in diff_dfs.keys(): diff_dfs[k] = diff_dfs[k].cache() return diff_dfs ","wordCount":"463","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Michal Piekarczyk"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://michal.piekarczyk.xyz/handy/databricks-spark/join-merge-parquet/"},"publisher":{"@type":"Organization","name":"michal.piekarczyk.xyz","logo":{"@type":"ImageObject","url":"https://michal.piekarczyk.xyz/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://michal.piekarczyk.xyz/ accesskey=h title="michal.piekarczyk.xyz (Alt + H)">michal.piekarczyk.xyz</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://michal.piekarczyk.xyz/post/ title=posts><span>posts</span></a></li><li><a href=https://michal.piekarczyk.xyz/project/ title=projects><span>projects</span></a></li><li><a href=https://michal.piekarczyk.xyz/handy/ title=handy><span>handy</span></a></li><li><a href=https://michal.piekarczyk.xyz/tags/ title=tags><span>tags</span></a></li><li><a href=https://michal.piekarczyk.xyz/about/ title=about><span>about</span></a></li><li><a href=https://world.hey.com/michal.piekarczyk title=frivolity><span>frivolity</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://michal.piekarczyk.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://michal.piekarczyk.xyz/handy/>Handies</a></div><h1 class=post-title></h1><div class=post-meta>3 min&nbsp;·&nbsp;463 words&nbsp;·&nbsp;Michal Piekarczyk</div></header><div class=post-content><h3 id=comparing-really-large-spark-dataframes>comparing really large spark dataframes<a hidden class=anchor aria-hidden=true href=#comparing-really-large-spark-dataframes>#</a></h3><p>I had this usecase where I wanted to be able to check if very large multi-million row and multi-thousand column dataframes were equal, but the advice online about using <code>df1.subtract(df2)</code> just was not cutting it because it was just too slow. It seems to me the <code>df1.subtract(df2)</code> approach more or less is a <code>O(n^2)</code> approach where it is necessary to compare each row in <code>df1</code> with each row in <code>df2</code>. Instead I was wondering, hey if there are known index columns in these dataframes, maybe we can cheat a little and join them first and then do the comparison after joining them.</p><p>What I came up with below so far does not handle the case yet of index keys that are not common. I would like to add that at some point. And for now this also requires the schemas of the dataframes to be the same.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>join_compare</span>(df1, df2, index_cols, head_n_rows<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, cache<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>):
</span></span><span style=display:flex><span>    <span style=color:#75715e># TODO fix to be outer join I think is needed? For now assumes all index cols match fully.</span>
</span></span><span style=display:flex><span>    assert_schema_equality_ignore_nullable(df1<span style=color:#f92672>.</span>schema, df2<span style=color:#f92672>.</span>schema)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> head_n_rows <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        df1 <span style=color:#f92672>=</span> df1<span style=color:#f92672>.</span>limit(head_n_rows)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    feature_cols <span style=color:#f92672>=</span> list(set(df1<span style=color:#f92672>.</span>columns) <span style=color:#f92672>-</span> set(index_cols))
</span></span><span style=display:flex><span>    which_type_names <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        x<span style=color:#f92672>.</span>name: x<span style=color:#f92672>.</span>dataType<span style=color:#f92672>.</span>typeName()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> df1<span style=color:#f92672>.</span>schema<span style=color:#f92672>.</span>fields
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> x<span style=color:#f92672>.</span>name <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> index_cols
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    double_cols <span style=color:#f92672>=</span> [k <span style=color:#66d9ef>for</span> (k, v) <span style=color:#f92672>in</span> which_type_names<span style=color:#f92672>.</span>items() <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;double&#34;</span>]
</span></span><span style=display:flex><span>    string_cols <span style=color:#f92672>=</span> [k <span style=color:#66d9ef>for</span> (k, v) <span style=color:#f92672>in</span> which_type_names<span style=color:#f92672>.</span>items() <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;string&#34;</span>]
</span></span><span style=display:flex><span>    integer_cols <span style=color:#f92672>=</span> [k <span style=color:#66d9ef>for</span> (k, v) <span style=color:#f92672>in</span> which_type_names<span style=color:#f92672>.</span>items() <span style=color:#66d9ef>if</span> v <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;integer&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># To find the actual doubles that are &lt; 1, calculate col means.</span>
</span></span><span style=display:flex><span>    stats_dict <span style=color:#f92672>=</span> dict(
</span></span><span style=display:flex><span>        df1<span style=color:#f92672>.</span>select([f<span style=color:#f92672>.</span>mean(k)<span style=color:#f92672>.</span>alias(k) <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> double_cols])
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>toPandas()
</span></span><span style=display:flex><span>        <span style=color:#f92672>.</span>to_dict(orient<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;records&#34;</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    double_cols_for_reals <span style=color:#f92672>=</span> [k <span style=color:#66d9ef>for</span> (k, v) <span style=color:#f92672>in</span> stats_dict<span style=color:#f92672>.</span>items() <span style=color:#66d9ef>if</span> v <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    integer_types_double_on_paper <span style=color:#f92672>=</span> [k <span style=color:#66d9ef>for</span> (k, v) <span style=color:#f92672>in</span> stats_dict<span style=color:#f92672>.</span>items() <span style=color:#66d9ef>if</span> v <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;all doubles:&#34;</span>,
</span></span><span style=display:flex><span>        len(double_cols),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;, doubles for real:&#34;</span>,
</span></span><span style=display:flex><span>        len(double_cols_for_reals),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    diff_dfs <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    double_sensitivity <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>
</span></span><span style=display:flex><span>    integer_condition <span style=color:#f92672>=</span> reduce(
</span></span><span style=display:flex><span>        or_,
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                (f<span style=color:#f92672>.</span>round(f<span style=color:#f92672>.</span>abs(f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;x.</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>) <span style=color:#f92672>-</span> f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;y.</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>))) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> (integer_types_double_on_paper <span style=color:#f92672>+</span> integer_cols)
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    string_condition <span style=color:#f92672>=</span> reduce(
</span></span><span style=display:flex><span>        or_, ([(f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;x.</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>) <span style=color:#f92672>!=</span> f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;y.</span><span style=color:#e6db74>{</span>col)<span style=color:#e6db74>&#34;)) for col in string_cols])</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    doubles_condition <span style=color:#f92672>=</span> reduce(
</span></span><span style=display:flex><span>        or_,
</span></span><span style=display:flex><span>        (
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                (f<span style=color:#f92672>.</span>abs(f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;x.</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>) <span style=color:#f92672>-</span> f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;y.</span><span style=color:#e6db74>{</span>col)<span style=color:#e6db74>&#34;)) &gt; double_sensitivity)</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> double_cols_for_reals
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        ),
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    rounded_cols <span style=color:#f92672>=</span> reduce(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>lambda</span> x, y: x <span style=color:#f92672>+</span> y,
</span></span><span style=display:flex><span>        [
</span></span><span style=display:flex><span>            (
</span></span><span style=display:flex><span>                f<span style=color:#f92672>.</span>round(f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;x.</span><span style=color:#e6db74>{</span>col)<span style=color:#e6db74>&#34;), 2).alias(f&#34;</span>x_{col}<span style=color:#e6db74>&#34;),</span>
</span></span><span style=display:flex><span>                f<span style=color:#f92672>.</span>round(f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;y.</span><span style=color:#e6db74>{</span>col)<span style=color:#e6db74>&#34;), 2).alias(f&#34;</span>y_{col}<span style=color:#e6db74>&#34;),</span>
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> double_cols_for_reals
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    select_integer_cols <span style=color:#f92672>=</span> reduce(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>lambda</span> x, y: x <span style=color:#f92672>+</span> y,
</span></span><span style=display:flex><span>        [
</span></span><span style=display:flex><span>            (f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;x.</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;y_ </span><span style=color:#e6db74>{</span>col)<span style=color:#e6db74>&#34;), f.col(f&#34;</span>y<span style=color:#f92672>.</span>{col}<span style=color:#e6db74>&#34;).alias(f&#34;</span>y_{col}<span style=color:#e6db74>&#34;))</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> (integer_types_double_on_paper <span style=color:#f92672>+</span> integer_cols)
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    select_string_cols <span style=color:#f92672>=</span> reduce(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>lambda</span> x, y: x <span style=color:#f92672>+</span> y,
</span></span><span style=display:flex><span>        [
</span></span><span style=display:flex><span>            (f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;x.</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;x_</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>), f<span style=color:#f92672>.</span>col(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;y.</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;y_</span><span style=color:#e6db74>{</span>col<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> col <span style=color:#f92672>in</span> string_cols
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;starting doubles_diff&#34;</span>)
</span></span><span style=display:flex><span>    diff_dfs[<span style=color:#e6db74>&#34;doubles_diffdf&#34;</span>] <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        df1<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;x&#34;</span>)<span style=color:#f92672>.</span>join(df2<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;y&#34;</span>), index_cols,
</span></span><span style=display:flex><span>                            )<span style=color:#f92672>.</span>where(doubles_condition)<span style=color:#f92672>.</span>select(<span style=color:#f92672>*</span>index_cols, <span style=color:#f92672>*</span>rounded_cols)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;starting integer diff&#34;</span>)
</span></span><span style=display:flex><span>    diff_dfs[<span style=color:#e6db74>&#34;integer_diffdf&#34;</span>] <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        df1<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;x&#34;</span>)<span style=color:#f92672>.</span>join(df2<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;y&#34;</span>), index_cols,
</span></span><span style=display:flex><span>                            )<span style=color:#f92672>.</span>where(integer_condition)<span style=color:#f92672>.</span>select(
</span></span><span style=display:flex><span>                                <span style=color:#f92672>*</span>index_cols, <span style=color:#f92672>*</span>select_integer_cols)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;starting string diff&#34;</span>)
</span></span><span style=display:flex><span>    diff_dfs[<span style=color:#e6db74>&#34;string_diffdf&#34;</span>] <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        df1<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;x&#34;</span>)<span style=color:#f92672>.</span>join(df2<span style=color:#f92672>.</span>alias(<span style=color:#e6db74>&#34;y&#34;</span>), index_cols,
</span></span><span style=display:flex><span>                            )<span style=color:#f92672>.</span>where(string_condition)<span style=color:#f92672>.</span>select(<span style=color:#f92672>*</span>index_cols, <span style=color:#f92672>*</span>select_string_cols)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> cache:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;caching&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> diff_dfs<span style=color:#f92672>.</span>keys():
</span></span><span style=display:flex><span>            diff_dfs[k] <span style=color:#f92672>=</span> diff_dfs[k]<span style=color:#f92672>.</span>cache()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> diff_dfs
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://michal.piekarczyk.xyz/>michal.piekarczyk.xyz</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>